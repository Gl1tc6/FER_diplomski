<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title></title></head><body>
<h1 align="center">MythSim User's Guide</h1>

<p align="center">By: Dale Reed and Jason Vroustouris</p>

<h2>Introduction</h2>

<blockquote>
  <p align="left">MythSim is a visual microcode simulator. It
can take   microcode, along with program code and data stored in memory,
and "execute" the code, with the computed results being written to memory.
The user   can step through the program, observing the values in the registers
and other   major components  of the CPU.&nbsp; MythSim makes it much easier
and less time consuming to   learn the details needed to succeed in a Computer
Architecture course.</p>
</blockquote>

<blockquote>
  <p>MythSim allows us to invent an assembly language of our choosing, and then
  implement this assembly language within our simulated CPU. Typically the
  assembly language we create will have elements that any assembly language
  would have in it, such as add, subtract, logical operations (and, or, not,
  xor), shift, multiply, memory read, and memory write. We could, however, come
  up with unique instructions, such as <font face="Courier New, Courier, mono">ADD3
  ri; </font>which would implement <font face="Courier New, Courier, mono">ri =
  ri + 3; </font>(ADD3 ri is of questionable usefulness.)</p>
  <p>By doing this we learn the "nuts and bolts" of how to control the datapath
  using a control unit of our own devising, which in turn should give a greater
  appreciation of programming language implementation and efficiency issues.
  This also helps us to understand how a computer actually works, "under
  the hood."</p>
  <p>Note that the micro programmed control unit could instead be equivalently
  rendered as a hard-wired control unit. The hard-wired control unit would be
  faster, however less flexible.</p>
</blockquote>

<h2 align="left">Getting Started</h2>

<h3 align="left">Downloading</h3>

<blockquote>
  <p align="left">Visit <a href="http://www.mythsim.org/">MythSim.org</a> to
  download the MythSim simulator. Note that you will need to have Java
  installed. The MythSim site has more information on this. Also take a look at
  the manual section at the MythSim site.</p>
</blockquote>

<h3>Running</h3>

<blockquote>
  <p>Once MythSim has been unzipped, you will have a file called mythsim.jar.
  Selecting this file will launch MythSim, the Java based simulator. In the
  initial window, select the File menu to load files. To run any
  "program" you must have two files, a ucode file and a memory file.
  The default extensions for these are <i>.ucode</i> for the ucode (microcode) file, and
  <i>.mem</i> for the memory file. Actually any text files will work. Be <i>sure</i>
  to load the right file in the right field, otherwise you will get a screen
  full of errors. The format of these two files is described further below.</p>
  <p>Once these files are loaded, you will want to bring up some of the windows
  under the window menu to watch the execution. You can watch the datapath,
  observe line by line as the microcode is executed, and watch line by line as
  the contents of main memory is retrieved and used.</p>
</blockquote>

  
<h3>Colors</h3>

<blockquote>
  <p align="left">The color of a highlights have meaning in MythSim. <font color="#ff0000"> Red</font>
  if for micro instructions.&nbsp; <font color="#0000ff">Blue</font> is for registers.&nbsp;
  <font color="#00ff00">Green</font> is for values in main memory.&nbsp;&nbsp;</p>
</blockquote>

<h2 align="left">Simulator Layout</h2>

<blockquote>
  <p align="left">The MythSim Application has a Main Window and a set of Viewing
  Windows.&nbsp;&nbsp;</p>
</blockquote>

<h3 align="left">Main Window</h3>

<blockquote>
  <p align="center"><img src="MainWindow.gif" title="" alt="MainWindow" style="width: 530px; height: 220px;"><br>
</p>
  <p align="left">The main window contains the main menu bar, tool bar, output
  screen and status bar.</p>
  <ul>
    <li>
      <p align="left"><b>Main Menu</b>
      </p><ul>
        <li>
          <p align="left">File - Open and Reload files.&nbsp; Exit simulator.
        </p></li><li>
          <p align="left">Run - Reset, step or run the simulator.
        </p></li><li>
          <p align="left">Window - Viewing Windows (see next section)
      </p></li></ul>
    </li>
    <li>
      <p align="left"><b>Tool Bar</b> - Duplicates functionality in file and run
      menus.
    </p></li><li>
      <p align="left"><b>Output Screen</b> - Displays error messages and status information
      about the simulator.
    </p></li><li>
      <p align="left"><b>Status Bar</b> - Gives basic feedback on the simulator.
      </p><ul>
        <li>
          <p align="left">Clock - The Current Clock cycle starting at clock
          cycle 0.
        </p></li><li>
          <p align="left">Current Memory Address - The address to be
          accessed in main memory.
      
    


  
</p>
          <p align="left"><u> </u>
        </p>
</li><li>
          <p align="left">Current Ucode Address - The address of the
          current micro instruction.</p></li></ul></li></ul></blockquote>
<h3 align="left">Viewing Windows</h3>

<blockquote>
  <p align="left">The viewing windows are located under the window menu.&nbsp; Most of the feedback from MythSim can be found
  in the main menu under the window menu.. These windows represent the key elements of the simulator such
  as the input file, datapath and registers.  Descriptions of what each 
window contains, along with example screen shots, are presented below.<u> </u></p>
</blockquote>

<div align="center">
  <center>
  <center>
    </center><table border="0" cellspacing="7" cellpadding="7" style="background-color: rgb(192,192,192); width: 850px;">
    <tbody><tr>
      <td style="vertical-align: top; background-color: rgb(255,255,255);" rowspan="1" colspan="2">
      <table cellpadding="2" cellspacing="2" border="0" style="text-align: left; width: 100%;">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><img style="border: 0px solid ; width: 300px; height: 406px;" src="ALUWindow.gif" title="" alt="ALU"></td>
            <td style="vertical-align: top;">The ALU provides a log of the ALU operations.&nbsp; In
  addition it shows other memory transfer operations on the Memory
  Interface. <br>
            </td>
          </tr>
        </tbody>
      </table>
      <p align="center">
      </p>
      </td>
    </tr>
<tr>
      <td valign="top" bgcolor="#ffffff" rowspan="1" colspan="2">
      <div style="text-align: center;">
        </div>
      <table cellpadding="2" cellspacing="2" border="0" style="text-align: left; width: 100%;">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><img style="border: 0px solid ; width: 475px; height: 425px;" src="DatapathWindow.gif" title="" alt="Datapath" width="475" height="425"></td>
            <td style="vertical-align: top;">Shows the current state of the data path.&nbsp; Red highlighting indicates
        that the signal was set in the current micro
        instruction.&nbsp; When a value is not explicitly set in
        microcode it will not appear as red.&nbsp;&nbsp; Notice that va_sel, vr0_write, and some other red signals are not
        control signals.&nbsp; <br>
            <br>
This diagram does not express the datapath completely.&nbsp;
        These <a href="diagrams/index.html">diagrams</a> show the complete
        datapath.&nbsp; These <a href="sketches/index.html">sketches</a>  also
        show that datapath.&nbsp; <br>
            <br>
Blue highlighting indicates
        that a register value has <u> </u>changed since the last clock cycle.<br>
            <br>
Notice that the alu inputs from the previous clock cycle are written
        in parentheses inside the ALU.&nbsp; The result of ALU operations can be
        verified by looking at the current a_bus, b_bus and previous ALU
        inputs. <br>
            </td>
          </tr>
        </tbody>
      </table>
</td>
      
    </tr>
    <tr>
      <td valign="top" bgcolor="#ffffff">
      <table cellpadding="2" cellspacing="2" border="0" style="text-align: left; width: 100%;">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><img style="border: 0px solid ; width: 330px; height: 176px;" src="MemoryWindow.gif" title="" alt="Memory Window" width="330" height="176"></td>
            <td style="vertical-align: top;">Shows the current values in main memory.&nbsp; The <b>Address </b>column
        contains the address of the low byte in each row.&nbsp; The <b>(low,
        high) </b>column shows the low and high byte in two's complement
        form.&nbsp; The low and high columns show these bytes in binary
        form.&nbsp; The green highlight reminds us that we are dealing with main
        memory.&nbsp; The<span style="font-size: 12pt; font-family: &quot;Nimbus Roman No9 L&quot;; color: black;"> memory is 256 bytes long
  with addresses ranging from 0 to 255</span></td>
          </tr>
        </tbody>
      </table>
</td>
  
      
    </tr>
  <tr>
      <td style="vertical-align: top; background-color: rgb(255,255,255);">
      <table cellpadding="2" cellspacing="2" border="0" style="text-align: left; width: 100%;">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><img style="border: 0px solid ; width: 162px; height: 498px;" src="MemoryFileWindow.gif" align="middle" title="" alt="Memory File" width="162" height="498"></td>
            <td style="vertical-align: top;">Shows the current memory file.&nbsp; The green reminds us that
we are dealing with main memory.</td>
          </tr>
        </tbody>
      </table>
      </td>
    </tr>
<tr>
      <td valign="top" bgcolor="#ffffff">
      <table cellpadding="2" cellspacing="2" border="0" style="text-align: left; width: 100%;">
        <tbody>
          <tr>
            <td style="vertical-align: top; text-align: left;">
            <p>
            <img src="RegistersWindow.gif" title="" alt="Register" style="width: 350px; height: 170px;">
        </p>
            </td>
            <td style="vertical-align: top;">
            <p>Shows a log of register values for each clock cycle.&nbsp; Each line
        has the 12 MythSim registers and the clock cycle in brackets.&nbsp; The
        blue highlight reminds us that we are dealing with registers.</p>

        
            <p>Adjusting the size of the window can provide different useful
        views.&nbsp; Shrink the window so one register will be on each
        line.&nbsp; This can be an alternative to the binary display in the
        datapath.&nbsp; Expand the window for one clock cycle per line.&nbsp;
        This is a good way to observe how the PC (Program Counter) and the MAR
        (Memory Address Register) change over time.</p>
            </td>
          </tr>
        </tbody>
      </table>
</td>
    </tr>
    <tr>
      <td colspan="2" valign="top" bgcolor="#ffffff">
        <p align="center">
        <a name="Ucode">
        <img style="border: 0px solid ; width: 788px; height: 126px;" src="UcodeWindow.gif" title="" alt="Ucode">
        </a>
        </p><p>Shows the ucode in tabular form. When the reload button is pressed this window is reloaded with the current
  values in the ucode file. These values can not be changes while a program is
  running. Each row of this table corresponds to a micro instruction in the ucode
  file.<u></u></p>
        <p>From a hardware perspective the ucode window shows the values in the memory
  located in the control-unit. Each row is a control word and each column is a
  control signal.</p></td>
    </tr>
  
    <tr>
      <td colspan="2" style="vertical-align: top; background-color: rgb(255,255,255);">
        <p align="center"><a name="Ucode File"><img style="border: 0px solid ; width: 559px; height: 178px;" src="UcodeFileWindow.gif" title="" alt="Ucode File"></a>
        </p><p align="left">Shows the ucode file with the current micro instruction highlighted.&nbsp;
        The red highlight reminds us that we are dealing with a micro
        instruction.
  </p></td>
    </tr>
  </tbody></table>
</center></div>

<h2>File Formats</h2>

<blockquote>
  <p>As mentioned above, each "program" is made up of two text files,
  the <i>memory </i>file and the <span style="font-style: italic;">ucode</span> file.&nbsp; The program
  to run, essentially an assembly language program, comes from the memory file.
  The ucode program implements the instruction set used in the assembly language
  program.</p>
</blockquote>
<h3>Memory (Mem) File</h3>

<blockquote>
    <p>A sample memory file corresponding to the above microprogram file is</p>
    <table border="0" style="background-color: rgb(192,192,192);" cellspacing="7" cellpadding="7">
      <tbody>
        <tr>
          <td style="background-color: rgb(255,255,255); height: 1px;">
            
          <a href="../../examples/guide.mem">guide.mem</a><br>
</td>
        </tr><tr>
        <td style="vertical-align: top; background-color: rgb(255,255,255);">Top section of program before the % can be used<br>

            for program comments.<br>

            Sum immediate constants into r0.<br>

            <br>
 %&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 // Begin code section<br>

            // LOAD_IMMEDIATE r0&lt;- 3&nbsp;&nbsp;<br>
 0: 3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 // values can be decimal..<br>

            1: 000010 00&nbsp;&nbsp;
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            //&nbsp;&nbsp; .. or binary<br>

            <br>

            // LOAD_IMMEDIATE r1&lt;- 2&nbsp;&nbsp;<br>

            2: 2<br>

            3: 000010 01<br>

            <br>

            // ADD r0 &lt;- r0 + r1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>

            4: 00 01 0000
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
            binary values can have spaces<br>

            5: 000001 00&nbsp;&nbsp;<br>

            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>

//
HALT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
 10: 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 // Should now have 5 in r0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>

            11: 000011 00<br>

            <br>

            // End</td>
      </tr>

      </tbody>
    </table>
    <br>
    Notes:
    <ul>
      <li>Comments can be written at the top of the file before the %, which
        marks the beginning of the code.
      </li><li>In-line comments can be given using //
      </li><li>Lines of code must have sequential line numbers given as labels,
        beginning with the first line at 0. Labels must be followed by a colon
        ':' as a delimiter.
      </li><li>Instruction values may be given as either decimal or binary values.
        Binary values can include spaces to make them more legible.
      </li><li>Instructions are <u> </u>typically  16 bits, however memory is byte-addressable, so it
        takes 2 bytes to make a single instruction. The low-order byte is given
        first in memory, then the high-order byte. This means that if in memory
        at addresses 4 and 5 we have the bytes:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00010000<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00000100<br>
        then the corresponding instruction is:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00000100 00010000<br>
        Where the right-most bit is the least-significant bit. The fact that
        each instruction is comprised of 2 bytes is why each instruction is
        shown as a pair of values, where each value is stored in a single byte.</li><li>Instructions can be longer than 16 bits, but the fetch-execute
cycle shown in the ucode file below deals with only 16 bit instructions.</li><li>Blank lines are allowed.</li>

    </ul></blockquote>
<h3>Microcode (ucode) File</h3>


<blockquote>
  <p>A sample microcode file is:</p>
    <table border="0" bgcolor="#c0c0c0" cellspacing="7" cellpadding="7">
      <tbody>
        <tr>
        <td valign="top" bgcolor="#ffffff"><a href="../../examples/guide.ucode">guide.ucode</a><br>
        </td>
      </tr>
<tr>
          <td height="212" bgcolor="#ffffff">// ========= FETCH =========<br>
            fetch0: a_sel=7, b_sel=7, alu_sel=AND, r6_write, mar_sel=LOAD;<br>
            fetch1: a_sel=6, c_in, alu_sel=ADDA, r7_write, ir0_sel=LOAD, read,
            if wait then goto fetch1 endif;<br>
            fetch2: a_sel=7, b_sel=7, alu_sel=AND, r6_write, mar_sel=LOAD;<br>
            fetch3: a_sel=6, c_in, alu_sel=ADDA, r7_write, ir1_sel=LOAD, read,
            if wait then goto fetch3 endif;
            <p>// ========= OPCODES =========<br>
            switch: goto opcode[IR_OPCODE];<br>opcode[0]:
 goto fetch0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &nbsp;// no_op<br>
            opcode[1]: ri_sel, rj_sel, rk_sel, alu_sel=ADD, goto fetch0; &nbsp;//
            add (ri &lt;- rj + rk)<br>
            opcode[2]: result_sel=IR_CONST8, ri_sel, goto fetch0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            &nbsp;// load immediate (ri &lt;- ir_const8)<br>
 opcode[3]: goto opcode[3];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &nbsp;// halt</p>
          </td>
        </tr>
      </tbody>
    </table>
  <br>
  Notes:
  <ul><li>Comments begin with //</li><li>labels are followed by a colon ':' as a delimiter. It is not necessary
      to have a label on every line.</li><li>Items within each instruction (after the label) are separated by commas
      ','. A semi-colon ';' is used as the end of instruction delimiter.</li><li>Items listed in each instruction represent setting that particular
      control line to 1. So for instance<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcode[1]: ri_sel, cin;<br>
      would represent setting the ri_sel control line and setting the cin
      control line to 1. All lines not listed are assumed to be 0.</li><li>Blank lines between instructions are allowed.</li><li>A typical microprogram will have three sections:
      <ul><li>The instruction <b> fetch</b> portion, usually about 4 lines (as shown
            above)</li><li>The <b> opcode</b> selection portion, where each opcode will correspond to
            exactly one line. This is implemented as a jump table, where the
            opcode retrieved from the instruction is the offset from the current
            PC value.</li><li>The opcode extension section. Operations that require more than a
            single microinstruction must have the remaining instructions given <i>below</i>
            the opcode jump table. Typically once each instruction is completed
            it will then branch back up to the beginning of instruction fetch
            again (e.g. fetch0). There is no opcode extension section in the
            above example, as all opcodes can be implemented in a single
            microinstruction.</li></ul>
    </li><li>The halt instruction is implemented as an unconditional branch to
      itself.</li><li>Each microcode instruction can be represented as binary values, where
      each control line that has been set is a value, and the rest are 0. This can
      be seen in the <a href="file:///home/jason/cs398/new/mythsim_3_0/xdocs/manual/users_guide/index.html#Ucode">Ucode Window</a>.</li></ul>
</blockquote>


<h3><br>
</h3>



<br>
<br>
</body></html>
